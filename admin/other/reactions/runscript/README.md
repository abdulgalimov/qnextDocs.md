# runScript

**runScript** — реакция позволит выполнить код, написанный на JavaScript и вернуть результаты выполнения. Внутри кода доступны объекты, которые содержат все переменные доступные во время выполнения реакции. Чтобы вернуть значение, используйте объект out. 

С помощью реакции runScript у вас будет больше возможности, вы сможете получить на выходе любое значение и сразу несколько, а не только результат последнего выражения как в макросе. Создайте реакцию runScript с кодом:
```js 
var a = 20;
var b = 10;
out.sum = a + b;
out.diff = a - b;
out.multiply = a * b
```

А следом реакцию message с текстом:
```plain 
Сумма: ${scriptResult.out.sum}
Разница: ${scriptResult.out.diff}
Произведение: ${scriptResult.out.multiply}
```

Вы получите такой вывод:
```plain 
Сумма: 30
Разница: 10
Произведение: 200
```

Как видите в любом месте скрипта вы можете вывести наружу значение с помощью переменной out, например `out.x = 123`. А потом использовать это значение с помощью переменной `${scriptResult.out.x}`.

Вы можете использовать любые конструкции языка JavaScript, если написать скрипт:
```js 
var a = 20;
var b = 10;
if (a > b) {
 out.result = "a > b"
} else {
 out.result = "a < b"
}
```

И попытаться вывести результат `${scriptResult.out.result}`,  вы получите на выходе строку `a > b`.

## Объект qnext
Для облегчения работы в скриптах доступен специальный объект qnext, у которого есть множество различных свойств и методов для упрощения работы в коде. Например если вы хотите в коде получить имя пользователя, вызвавшего эту реакцию, можно воспользоваться функцией `qnext.getValue()`:

`out.result = "Имя пользователя: " + qnext.getValue("user.name");`

Функция `qnext.getValue` возвращает значение переменной имеющейся в тригере. В качестве аргумента этой функции необходимо передать путь до переменной.
::: tip ℹ️
Если вы не помните путь до переменной воспользуйтесь реакций ⚡️log и найдите необходимую переменную на странице просмотра логов: [**Логи**](/docs/admin/other/reactions/log)
:::

У объекта qnext доступны множество различных вспомогательных объектов и функций, все они описаны на странице [QNext. Скрипты. Объект qnext](/docs/ext/script/object-qnext).


## Асинхронный режим
Под асинхронным режимом понимается возможность использовать в коде конструкции вида `async/await`. Чтобы реакция не завершилась до окончания выполнения async функции, включите галочку ☑️`asyncMode` в настройках реакции ⚡️`runScript` и после окончания выполнения вашего кода, вызовите функцию `qnext.onFinish()`:
```js 
async function run() {
  // здесь ваш асинхронный код
  qnext.onFinish();
}
run();
```

Если функцию `qnext.onFinish` не вызвать, то скрипт будет завершен аварийно по таймауту. В функцию `qnext.onFinish` можно передать что угодно, и это будет записано в переменную `${scriptResult.out.finish}`.

Если вы используете макрос, тогда в настройках макроса необходимо указать параметр `asyncMode`:
```plain 
!{script|
  asyncMode;
  code: Вашкод... 
}
```

⚠️В асинхронном режими скрипт работает намного дОльше чем точно такой же скрипт не в асинхронном режиме.

### Примеры скриптов

1. [Отслеживание N сообщений подряд от одного пользователя, длиной менее L символов](https://t.me/QNextCases/145)
2. [Выбор случайных значений из указанного диапазона чисел](https://t.me/QNextCases/170)
3. [Работа с глобальными переменными](https://t.me/QNextCases/199)
4. [Удаление всех сообщений в чате между командой и reply сообщением](https://t.me/QNextCases/212)

### Пример работы реакции для использования методов bot.api: sendMessage

⚡ localVarSet — число — chat_id = ${update.message.chat.id}

⚡ localVarSet — трока — text = произвольный текст

```plain 

async function run() {
  var body = {};
  body.chat_id = qnext.getValue("localVar.chat_id");
  body.text = qnext.getValue("localVar.text");
  body.reply_markup = {
    inline_keyboard: [
      [{
        text: "Examplesqnextbot",
        url: "https://t.me/Qnext_Examplebot"
      }]
    ]
  }
  var result = await qnext.telegram.api("sendMessage", body);
  exports.result = result;
}
run().finally(qnext.onFinish);

```